<!DOCTYPE html>
<html>
<head>

<title>Radiance - Web Animation</title>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.js"></script>
<script src="raphael.js"></script>
<script src="json.js"></script>
<style type="text/css">
body {
  width: 960px;
  margin: 0 auto;
}
.hidden {
  display: none;
}
h1, h2, #nav {
  margin: 0;
  text-align: center;
}
#nav, #menubar {
  margin: .5em;
}
input {
  width: 40px;
}
#toolbar {
  float: left;
  border: solid 1px black;
  height: 560px;
  width: 100px;
}
#toolbar p {
  margin: 0;
  font-size: .8em;
}
#rect_button span {
  display: inline-block;
  border: solid 1px black;
  height: 6px;
  width: 8px;
}
#newsave {
  padding: .5em;
}
#zoomslider {
  position: relative;
  top: 5px;
}
#user_canvas {
  float: left;
  border: solid 1px black;
  position: relative;
}
.spotlight svg * {
  opacity: .4;
}
.spotlight .spotlight, .spotlight .spotlight * {
  opacity: .8;
}
#shapes_list {
  float: left;
  border: solid 1px black;
  height: 480px;
  width: 200px;
  overflow-y: scroll;
}
#shapes_list p {
  margin: 0;
  cursor: pointer;
}
#shapes_list .current {
  background-color: mediumblue;
  color: white;
}
#list_shape_options {
  font-size: 80%;
  padding: 0 1ex;
  background-color: #DFF;
}
#list_shape_options input {
  width: 100px;
}
#user_canvas_controls {
  float: left;
  border: solid 1px black;
}
#timeslider {
  position: relative;
  top: 10px;
}
</style>

</head>
<body>

<h1>Radiance <small>v0.0&alpha;</small></h1>
<h2>JavaScript Web Animation</h2>

<p id="nav">
  <a href="/">Radiance</a> |
  <a href="instructions">Instructions</a> |
  <a href="about">About</a> |
  <a href="news">News</a>
</p>

<div id="toolbar">
  <p><button id="rect_button"><span></span> Rect</button>
  <p class="hidden">Thickness
    <br>Corner Radius
    <br>Fill
  <p><button id="ellipse_button">Ellipse</button>
  <p class="hidden">Thickness
    <br>Fill
  <p><button id="text_button">Text</button>
  <p class="hidden">Size
    <br>Font
  <p><button id="line_button">Line</button>
  <p class="hidden">Thickness
  <p><button id="move_button">Move</button>
  <p class="hidden">Choose a shape from the list
</div>

<p id="menubar">
  <span id="newsave">
    <button disabled>New</button>
    <button disabled>Save</button>
    <button disabled>Undo</button>
    <button disabled>Redo</button>
  </span>
  <label for="width">Width:</label>
  <input type="text" id="width" value=640 disabled>
  <label for="height">Height:</label>
  <input type="text" id="height" value=480 disabled>
  <label for="zoom">Zoom:</label>
  <input type="text" id="zoom" value="100%" disabled>
  <span id="zoomslider"></span>
</p>

<div id="user_canvas"></div>

<div id="shapes_list"></div>

<div id="user_canvas_controls">
  <button>&#9654;Play</button>
  <span id="timeslider"></span>
  <input type="text" id = "current_time" value="0.000s">/<input type="text" id = "duration" value="5.000s">
</div>

<button id="embed">Embed this in your Web page</button>

<script type="text/javascript">
//by David Allen (github.com/voronoff davidrallen1@gmail.com) and Han Wei (github.com/laughinghan laughinghan@gmail.com)

var zoomslider = Raphael('zoomslider', 200, 20),
  zoombar = zoomslider.path('M 0 10 L 200 10'),
  zoom_overlay = zoomslider.rect(0, 0, 200, 20).attr({fill:'#000', opacity: 0}),
  zoomknob = zoomslider.rect(50, 0, 6, 20).attr({fill: '#AAA', stroke: 'none'});

var zoom = 100, zoom_startX;
zoom_overlay.drag(zoom_drag, function(x, y, e){ //start
  zoom_startX = e.pageX - $('#zoomslider').offset().left - 1;
  zoom = zoom_startX + 50;
  $('#zoom').val(zoom+'%');
  zoomknob.attr('x', zoom_startX - 3);
}); //zoom!
zoomknob.drag(zoom_drag, function(){ //start
  zoom_startX = zoomknob.attr('x') + 3;
}); //zoom!!
function zoom_drag(dx, dy){
  zoom = zoom_startX + dx + 50;
  zoom = zoom < 50 ? 50 : (zoom > 250 ? 250 : zoom);
  $('#zoom').val(zoom+'%');
  zoomknob.attr('x', zoom - 53);
} //zoom!!!


var slider_length = 480;



var timeslider = Raphael('timeslider', slider_length, 30),
  timebar = timeslider.path('M 0 15, L '+slider_length+' 15'),
  time_overlay = timeslider.rect(0, 0, slider_length, 30).attr({fill:'#000', opacity: 0}),
  timeknob = timeslider.rect(-3, 5, 6, 20).attr({fill: '#000', stroke: 'none'});

var now = 0, time_startX, duration = 5000;
time_overlay.drag(time_drag, function(x, y, e){ //start
  if(playing) //then pause
    play_button.click();

  time_startX = e.pageX - $('#timeslider').offset().left - 1;
  now = Math.round(time_startX*duration/slider_length);
  current_time.val((now/1000).toFixed(3)+'s');
  timeknob.attr('x', time_startX - 3);
  shapes_list.children().each(interpolate_anim_state);
});
timeknob.drag(time_drag, function(){ //start
  time_startX = timeknob.attr('x') + 3;
  if(playing) //then pause
    play_button.click();
});
function time_drag(dx, dy){
  now = Math.round((time_startX+dx)*duration/slider_length);
  now = now < 0 ? 0 : (now > duration ? duration : now);
  current_time.val((now/1000).toFixed(3)+'s');
  timeknob.attr('x', now*slider_length/duration - 3);
  shapes_list.children().each(interpolate_anim_state);
}

var past_n_now = 0, anim_start;
Raphael.easing_formulas.time_easing = function(n){
  now = anim_start + n * (duration - anim_start);
  if (n - past_n_now > .014){
    past_n_now = n;
    current_time.val((now/1000).toFixed(3)+'s');

    //and hacky way of updating fields for play
    (current_list_shape.data('remove list options') || $.noop)();
    (current_list_shape.data('add list options') || $.noop)();

  }
  return n;
}

//to optimize play button and interpolate, make so if ele hidden, it doesn't go through it for all attr,
//just sets them all with an interpolate_anim_state when becomes unhidden
//Play button
var playing = false,
  play_button = $('#user_canvas_controls button').click(function(){
  if(playing){
    play_button.html('&#9654;Play');
    playing = false;
    shapes_list.children().each(function(){
      var raphael_this = $(this).data('raphael');
      raphael_this && raphael_this.stop();
    });
    timeknob.stop();
    return;
  }
  play_button.html('Pause');
  playing = true;
  if(now === duration){
    now = 0;
    timeknob.attr('x', -3);
    current_time.val('0.000s');
  }
  anim_start = now;
  shapes_list.children().each(interpolate_anim_state);
  shapes_list.children().each(function(){ //recursive animation
    var raphael_this = $(this).data('raphael'), chronology = $(this).data('chronology');
    for(var attr in chronology)
      (function(attr){
        (function(){
          if(attr === 'hidden' || attr === 'fill-opacity' || attr === 'text'){
            var prev = 0;
            for(var next in chronology[attr]) //iterate through each singularity
              if(next > now) //until the first singularity after now
                break;
              else{
                prev = next; //let prev be the last singularity before now
                next = -1; //if the singularity wasn't after now, flag
              }
            if(attr === 'hidden')
              raphael_this.toggleHide(chronology.hidden[prev]);
            else
              raphael_this.attr(attr, chronology[attr][prev]);
            if(next >= 0) //only recurse if there is another singularity after now
              setTimeout(arguments.callee, next - now);
            return;
          }
          var new_attr = {};
          for(var next in chronology[attr]) //iterate through each singularity
            if(next > now) //until the first singularity after now
              break;
            else
              next = -1; //if the singularity wasn't after now, flag
          if(next < 0) //if no singularities after now in chronology, don't animate
            return;
          new_attr[attr] = chronology[attr][next];
          raphael_this.animate(new_attr, next - now, arguments.callee);
        }());
      }(attr));
  });
  past_n_now = 0
  timeknob.animate({x: 477}, duration - now, 'time_easing', function(){
    now = duration;
    playing = false;
    play_button.html('&#9654;Play');
    current_time.val((now/1000).toFixed(3)+'s');
    interpolate_anim_state();
  });
});

//interpolate current animation state
function interpolate_anim_state(){
  var raphael_this = $(this).data('raphael'), chronology = $(this).data('chronology');

  if(raphael_this === undefined)
    return;

  for(var attr in chronology){
    //binary attributes
    if(attr === 'hidden' || attr === 'fill-opacity' || attr === 'text'){
      var prev = 0;
      for(var next in chronology[attr]) //iterate through each singularity
        if(next > now) //until the first singularity after now
          break;
        else
          prev = next; //let prev be the last singularity before now
      if(attr === 'hidden')
        raphael_this.toggleHide(chronology.hidden[prev]);
      else
        raphael_this.attr(attr, chronology[attr][prev]);
      continue;
    }

    var past = 0, future = duration + 1;

    //seek singularity closest but <= now
    for(var time in chronology[attr])
      if(time <= now && time > past)
        past = +time;

    //seek singularity closest but >= now
    for(var time in chronology[attr])
      if(time >= now && time < future)
        future = +time;

    if(future === past || future > duration)
      raphael_this.attr(attr, chronology[attr][past]);
    else{
      var delta = (now - past)/(future - past);
      if(attr === 'path'){
        var past_path = chronology.path[past],
          future_path = chronology.path[future],
          path = $(this).data('path');
        path.startX = interpolate(past_path[0][1], future_path[0][1]);
        path.startY = interpolate(past_path[0][2], future_path[0][2]);
        path.endX = interpolate(past_path[1][1], future_path[1][1]);
        path.endY = interpolate(past_path[1][2], future_path[1][2]);
        raphael_this.attr('path', path);
      }else if(attr in {fill:0,stroke:0}){
        var past_rgb = Raphael.getRGB(chronology[attr][past]),
          future_rgb = Raphael.getRGB(chronology[attr][future]);
        raphael_this.attr(attr, 'rgb(' +
          interpolate(past_rgb.r, future_rgb.r) + ',' +
          interpolate(past_rgb.g, future_rgb.g) + ',' +
          interpolate(past_rgb.b, future_rgb.b) + ')');
      }else
        raphael_this.attr(attr, interpolate(chronology[attr][past], chronology[attr][future]));
      }
  }
  function interpolate(past, future){
    return +past + +((future - past)*delta); //eventually use real easing
  }

  //hacky hacky way of making interpolate change fields
  if (raphael_this === current_list_shape.data('raphael')){
    current_list_shape.data('remove list options')();
    current_list_shape.data('add list options')();
  }
}

//set the current time when people type into #current_time text box live,
//change to 3 decimal place + s format after they hit enter or leave the text box
var current_time = $('#current_time').bind('keydown keypress', defer(function(){
  now = parseFloat(current_time.val()) * 1000;
  if(now > duration)
    now = duration;
  if(now < 0)
    now = 0;
  timeknob.attr('x', now*slider_length/duration - 3);
  shapes_list.children().each(interpolate_anim_state);
})).change(function(){
  current_time.val((now/1000).toFixed(3) + 's');
});

//change duration upon change of #duration text box. Not live.
$('#duration').change(function(){
  duration = parseFloat($('#duration').val(), 3) * 1000;
  if(duration < 0)
    duration = 0;
  timeknob.attr('x', now*slider_length/duration - 3);
  $('#duration').val((duration/1000).toFixed(3) + 's')
});

//defer execution by a thread. Used by live text input boxes
function defer(fn){
  return function(){
    setTimeout(fn);
  };
}

//based on Raphael.el.show and .hide in Raphael.js v1.5.2
Raphael.el.toggleHide = function(hide){
  !this.removed && (this.node.style.display = hide ? 'none' : '') || this.paper.safari();
  return this;
};



//clicking anywhere but on a shape should unselect shape
$(document).click(function(){
  (current_list_shape.removeClass('current').data('remove list options') || $.noop)();
  current_list_shape = $();
  list_shape_options.detach();
});

//list of raphael shapes and sets
var shapes_list = $('#shapes_list').click(function(e){
    if(e.target !== this)
      e.stopPropagation();
  });

//shape in list, options thereof
var current_list_shape = $(), list_shape_options = $('<p id="list_shape_options"></p>'),
  //rename
  rename = $('<p><label for="rename_option">Name: </label><input type="text" name="rename" id="rename_option"></p>')
    .appendTo(list_shape_options).find('input').bind('keydown keypress', defer(function(){
      var name = rename.val();
      if(all_spaces_regex.test(name))
        list_shape_options.prev().html('&nbsp;');
      else
        list_shape_options.prev().text(name);
    })),
  //hidden
  hidden = $('<p><label for="hidden_option">Hidden: </label><input type="checkbox" id="hidden_option" name="hidden_option"></p>')
    .appendTo(list_shape_options).find('input').change(function(){
      var chronology = current_list_shape.data('chronology');
      if(!chronology.hidden)
        chronology.hidden = [ true ];
      current_list_shape.data('raphael').toggleHide(chronology.hidden[now] = this.checked);
    })[0],
  //remove
  remove = $('<button>Remove</button>').click(function(){
    (current_list_shape.data('remove list options') || $.noop)();
    list_shape_options.detach();

    current_list_shape.data('raphael').remove();
    current_list_shape.remove();

    current_list_shape = $();
  }).appendTo(list_shape_options),
  all_spaces_regex = /^ *$/;

//click handler attached to each list item in list of shapes
function list_shape_click(){
  (current_list_shape.removeClass('current').data('remove list options') || $.noop)();
  current_list_shape = $(this).addClass('current');

  rename.val(this.innerHTML === '&nbsp;' ? '' : this.innerHTML);
  hidden.checked = current_list_shape.data('raphael').node.style.display === 'none';
  current_list_shape.data('add list options')();

  list_shape_options.insertAfter(this);
}

//limits decimal places for values for anim/interpolate
function prettify_val(value){
  if (value){
    if(+value === +(+value).toFixed(3))
        return +value;
    else{
      var suffix = (value+'').replace(/[0-9]*\.*[0-9]*/, ''), number = parseFloat(value).toFixed(3)
      ;
      if (number === 'NaN')
        return 1;
      else
        return number + ' ' + suffix;
    }
  }
}


//additional options to be added on a per-shape basis:
function add_attr_option(raphael_shape, attr, chronology){
  var attr_option = $('<p><label for="'+attr+'_option">'+attr+' : </label><input type="text" name="'+attr+'" id="'+attr+'_option"></p>'),
    attr_input = attr_option.find('input').bind('keydown keypress', defer(function(){
      var val = attr_input.val();
      chronology[attr][now] = raphael_shape.attr(attr, num_dot_regex.test(val) ? val.slice(0, -1) : val).attr(attr);
    })).val(prettify_val(raphael_shape.attr(attr)));
  return attr_option.insertBefore(remove);
}
var num_dot_regex = /^\d+\.$^/; //fix annoying css quirk where '123.' is an invalid number and is interpreted as 0

//stroke width
var stroke_width_option = $('<p><label for="stroke_width_option">Thickness: </label><input type="text" name="stroke" id="stroke_width_option"></p>'),
  stroke_width_input = stroke_width_option.find('input').bind('keydown keypress', defer(function(){
    var raphael_shape = current_list_shape.data('raphael'), chronology = current_list_shape.data('chronology');
    if(!raphael_shape.attr('stroke'))
      raphael_shape.attr('stroke', '#000');
    if(!chronology['stroke-width'])
      chronology['stroke-width'] = [ raphael_shape.attr('stroke-width')  || 1 ];
    chronology['stroke-width'][now] = raphael_shape.attr('stroke-width', stroke_width_input.val()).attr('stroke-width');
  }));
function add_stroke_width(raphael_shape){
  stroke_width_input.val(prettify_val(raphael_shape.attr('stroke-width')) || 1);
  stroke_width_option.insertBefore(remove);
}
function rm_stroke_width(){
  stroke_width_option.detach();
}

//stroke color
var stroke_color_option = $('<p><label for="stroke_color_option">Color: </label><input type="text" name="stroke_color_option" id="stroke_color_option">'+
    '<select><option></option><option>Red</option><option>Orange</option><option>Yellow</option><option>Green</option><option>Blue</option>'+
    '<option>Purple</option><option>Black</option><option>Gray</option><option>White</option></select></p>'),
  stroke_color_input = stroke_color_option.find('input').bind('keydown keypress', defer(function(){
    var raphael_shape = current_list_shape.data('raphael'), chronology = current_list_shape.data('chronology'), stroke_color_val = stroke_color_input.val();
    if(!raphael_shape.attr('stroke-opacity'))
      raphael_shape.attr('stroke-opacity', 1);
    if(!chronology['stroke'])
      chronology['stroke'] = [ raphael_shape.attr('stroke') ];
    raphael_shape.attr('stroke', chronology['stroke'][now] = stroke_color_val);
    stroke_color_select.val(stroke_color_val);
  })),
  stroke_color_select = stroke_color_option.find('select').change(function(){
    stroke_color_input.val(this.value).keydown();
  });
function add_stroke_color(raphael_shape){
  stroke_color_input.val(raphael_shape.attr('stroke'));
  stroke_color_option.insertBefore(remove);
}
function rm_stroke_color(){
  stroke_color_option.detach();
}

//fill
var fill = $('<p><label for="fill">Fill: </label><input type="checkbox" id="fill" name="fill"></p>'),
  fill_checkbox = fill.find('input').change(function(){
    var chronology = current_list_shape.data('chronology'), raphael_shape = current_list_shape.data('raphael');
    if(!chronology['fill-opacity'])
      chronology['fill-opacity'] = [ raphael_shape.attr('fill-opacity') ];
    raphael_shape.attr('fill-opacity', chronology['fill-opacity'][now] = +this.checked);
  });
function add_fill(raphael_shape){
  fill_checkbox[0].checked = raphael_shape.attr('fill-opacity') === 1;
  fill.insertBefore(remove);
}
function rm_fill(){
  fill.detach();
}

//fill color
var fill_color_option = $('<p><label for="fill_color_option"></label><input type="text" name="fill_color_option_text_color" id="fill_color_option_text_color">'+
    '<select><option></option><option>Red</option><option>Orange</option><option>Yellow</option><option>Green</option><option>Blue</option>'+
    '<option>Purple</option><option>Black</option><option>Gray</option><option>White</option></select></p>'),
  fill_color_input = fill_color_option.find('input').bind('keydown keypress', defer(function(){
    var raphael_shape = current_list_shape.data('raphael'), chronology = current_list_shape.data('chronology'), fill_color_val = fill_color_input.val();
    if(!chronology.fill)
      chronology.fill = [ raphael_shape.attr('fill') ];
    raphael_shape.attr('fill', chronology.fill[now] = fill_color_val);
    fill_color_select.val(fill_color_val);
  })),
  fill_color_select = fill_color_option.find('select').change(function(){
    fill_color_input.val(this.value).keydown();
  }),
  fill_color_label = fill_color_option.find('label');
  function add_fill_color(raphael_shape, label){
    fill_color_input.val(raphael_shape.attr('fill'));
    fill_color_label.text(label + ': ');
    fill_color_option.insertBefore(remove);
  }
  function rm_fill_color(){
    fill_color_option.detach();
  }



//the Raphael canvas on which all the shapes are drawn
var user_canvas = Raphael('user_canvas', 640, 480), user_canvas_div = $('#user_canvas');
user_canvas.text(200,150,'hello world').attr('font-size',40);



//highlight a Raphael shape in the user_canvas
var spotlight = (function(){
  var spotlit_shape;
  function spotlight(shape){
    user_canvas_div.addClass('spotlight');
    (spotlit_shape = shape.node).setAttribute('class','spotlight');
  }
  function off(){
    user_canvas_div.removeClass('spotlight');
    spotlit_shape.removeAttribute('class');
  }
  spotlight.off = off;
  return spotlight;
}());



//drag-and-drop subroutine
//USAGE: drag([event Object], [mousemove handler function(dx, dy){...}]);
var drag = (function(){
  var doc = $(document), initialX, initialY, onmove, onup;
  function mousemove(e){
    onmove(e.clientX - initialX, e.clientY - initialY);
    return false;
  }
  function mouseup(){
    spotlight.off();
    doc.unbind('mousemove mouseup');
    onup();
    return false;
  }
  function drag(e, move, up){
    initialX = e.clientX;
    initialY = e.clientY;
    onmove = move;
    onup = up;
    doc.mousemove(mousemove).mouseup(mouseup);
  }
  return drag;
}());



//canonical 'current' mousedown handler on all shapes in the user canvas
//(set by e.g. Move button, then reset by click handler for all toolbars)
var raphael_shape_mousedown = $.noop;
//calls the canonical 'current' click handler,
//attached to all shapes on creation (e.g. rect)
function call_raphael_shape_mousedown(){
  raphael_shape_mousedown.apply(this, arguments);
}



//show/hide toolbar button options
var current_button_description = $();
$('#toolbar button').click(function(){
  //there'll be a better way to know current tool when it's a span with a background color and whatever instead of a <button>
  if(current_button_description[0] === $(this).parent().next()[0])
    return;

  text_button_flag = false;
  current_button_description.hide();
  current_button_description = $(this).parent().next().show();

  //reset event handlers
  user_canvas_div.unbind().click(false);
  raphael_shape_mousedown = function(){$(this.node).data('shapes list').click()};

  return false;
});


/****
So at this point, checklist for creating user shapes:
user_canvas.<Raphael API call>.attr(<more Raphael API>)
  .mousedown(call_raphael_shape_mousedown); //bound to every user_canvas shape
//next, item in shapes list
$('<some html>').data('raphael', <previously_created_Raphael_shape_in_user_canvas>)
  .data('add list options', function(){
    //when this list item is clicked, add options
  }).data('remove list options', function(){
    //when another list item is clicked, remove options
  }).click(list_shape_click) //bound to every list item
  .appendTo(shapes_list);
$(<previously_created_Raphael_shape_in_user_canvas>.node)
  .data('shapes list', <previously_created_shapes_list_item_jQ>);
//and most likely spotlight the shape in user_canvas
spotlight(<previously_created_Raphael_shape_in_user_canvas>);
****/


function moved_xy(){
  this.attr_options().find('input')[0].value = this.attr('x');
  this.attr_options().find('input')[1].value = this.attr('y');
}
function moved_cxcy(){
  this.attr_options().find('input')[0].value = this.attr('cx');
  this.attr_options().find('input')[1].value = this.attr('cy');
}
function doneMoving_xy(){
  current_list_shape.data('chronology')['x'][now] = this.attr('x');
  current_list_shape.data('chronology')['y'][now] = this.attr('y');
}
function doneMoving_cxcy(){
  current_list_shape.data('chronology').cx[now] = this.attr('cx');
  current_list_shape.data('chronology').cy[now] = this.attr('cy');
}


//rectangle tool
var rect_count = 0;
$('#rect_button').click(function(){
  user_canvas_div.mousedown(function(e){
    rect_count += 1;
    var cornerX = e.pageX - user_canvas_div.offset().left, cornerY = e.pageY - user_canvas_div.offset().top, chronology = {}, attrs = $(),
      rect = user_canvas.rect(cornerX, cornerY, 0, 0).attr({fill: 'black', 'fill-opacity': 0})
        .mousedown(call_raphael_shape_mousedown),
      list_jQ = $('<p>Rectangle '+rect_count+'</p>').data('raphael', rect)
        .data('chronology', chronology)
        .data('add list options', function(){
          $.each(['x', 'y', 'width', 'height', 'rotation'], function(i, attr){
            attrs = attrs.add(add_attr_option(rect, attr, chronology));
          });
          add_stroke_width(rect);
          add_stroke_color(rect);
          add_fill(rect);
          add_fill_color(rect, 'Fill color');
        })
        .data('remove list options', function(){
          attrs.remove();
          attrs = $();
          rm_stroke_width();
          rm_stroke_color();
          rm_fill();
          rm_fill_color();
        })
        .click(list_shape_click)
        .hover(function(){
          spotlight(rect);
        }, function(){
          spotlight.off();
        })
        .appendTo(shapes_list);
    rect.attr_options = function(){return attrs;};
    rect.moved = moved_xy;
    rect.doneMoving = doneMoving_xy;
    $(rect.node).data('shapes list', list_jQ);

    spotlight(rect);

    drag(e, function(dx, dy){
      if(dx < 0)
        rect.attr({
          width: -dx,
          x: cornerX + dx
        });
      else
        rect.attr({
          width: dx,
          x: cornerX
        });
      if(dy < 0)
        rect.attr({
          height: -dy,
          y: cornerY + dy
        });
      else
        rect.attr({
          height: dy,
          y: cornerY
        });
    }, function(){
      if(+(rect.attr('width')) === 0 || +(rect.attr('height')) === 0){
        rect.remove();
        list_jQ.remove();
        rect_count -= 1;
        return;
      }

      list_shape_click.call(list_jQ[0]);

      $.each(['x', 'y', 'width', 'height', 'rotation'], function(i, attr){
        chronology[attr] = [ rect.attr(attr) ];
      });
    });

    if(now != 0){
      chronology.hidden = [ true ];
      chronology.hidden[now] = false;
    }

    return false;
  });
});

//ellipse tool
var ellipse_count = 0;
$('#ellipse_button').click(function(){
  user_canvas_div.mousedown(function(e){
    ellipse_count += 1;
    var cornerX = e.pageX - user_canvas_div.offset().left, cornerY = e.pageY - user_canvas_div.offset().top, chronology = {}, attrs = $(),
      ellipse = user_canvas.ellipse(cornerX, cornerY, 0, 0).attr({fill: 'black', 'fill-opacity': 0})
        .mousedown(call_raphael_shape_mousedown),
      list_jQ = $('<p>Ellipse '+ellipse_count+'</p>').data('raphael', ellipse)
        .data('chronology', chronology)
        .data('add list options', function(){
          $.each(['cx', 'cy', 'rx', 'ry', 'rotation'], function(i, attr){
            attrs = attrs.add(add_attr_option(ellipse, attr, chronology));
          });
          add_stroke_width(ellipse);
          add_stroke_color(ellipse);
          add_fill(ellipse);
          add_fill_color(ellipse, 'Fill color');
        })
        .data('remove list options', function(){
          attrs.remove();
          attrs = $();
          rm_stroke_width();
          rm_stroke_color();
          rm_fill();
          rm_fill_color();
        })
        .click(list_shape_click)
        .hover(function(){
          spotlight(ellipse);
        }, function(){
          spotlight.off();
        })
        .appendTo(shapes_list);
    ellipse.attr_options = function(){return attrs;};
    ellipse.moved = moved_cxcy;
    ellipse.doneMoving = doneMoving_cxcy;
    $(ellipse.node).data('shapes list', list_jQ);

    spotlight(ellipse);

    drag(e, function(dx, dy){
      if(dx < 0)
        ellipse.attr({
          rx: -dx,
        });
      else
        ellipse.attr({
          rx: dx,
        });
      if(dy < 0)
        ellipse.attr({
          ry: -dy,
        });
      else
        ellipse.attr({
          ry: dy,
        });
    }, function(){
      if(+(ellipse.attr('rx')) === 0 || +(ellipse.attr('ry')) === 0){
        ellipse.remove();
        list_jQ.remove();
        ellipse_count -= 1;
        return;
      }
      list_shape_click.call(list_jQ[0]);

      $.each(['cx', 'cy', 'rx', 'ry', 'rotation'], function(i, attr){
        chronology[attr] = [ ellipse.attr(attr) ];
      });
    });

    if(now != 0){
      chronology.hidden = [ true ];
      chronology.hidden[now] = false;
    }

    return false;
  });
});

//text tool
var text_count = 0, text_button_flag = false;
$('#text_button').click(function(){
  text_button_flag = true;
  user_canvas_div.click(function(e){
    text_count += 1;
    var text = user_canvas.text(e.pageX - user_canvas_div.offset().left, e.pageY - user_canvas_div.offset().top, 'text').attr('font-size',24).mousedown(call_raphael_shape_mousedown).click(function(e){
      if(text_button_flag === true)
        e.stopPropagation();
    }),
      chronology = {}, attrs = $(),
      text_option = $('<p id="text_option_p"><label for="text_option">Text: </label><input type="text" id="text_option" name="text_option" value="text"></p>'),
      text_opt_input = text_option.find('input').bind('keydown keypress', defer(function(){
        text.attr('text', text_opt_input.val());
        current_list_shape.data('chronology')['text'][now] = text.attr('text');
      })),
      list_jQ = $('<p>Text ' + text_count + '</p>').data('raphael', text)
        .data('chronology', chronology)
        .data('add list options', function(){
          text_option.insertBefore(remove);
          $.each(['x', 'y', 'rotation', 'font-size'], function(i, attr){
            attrs = attrs.add(add_attr_option(text, attr, chronology));
          });
          add_fill_color(text, 'Color');
        })
        .data('remove list options', function(){
          attrs.remove();
          attrs = $();
          text_option.detach();
          rm_fill_color();
        })
        .click(list_shape_click)
        .hover(function(){
          spotlight(text);
        }, function(){
          spotlight.off();
        })
        .appendTo(shapes_list);
    text.attr_options = function(){return attrs;};
    text.moved = moved_xy;
    text.doneMoving = doneMoving_xy;
    $(text.node).data('shapes list', list_jQ);

    list_shape_click.call(list_jQ[0]);
    text_opt_input.focus();

    $.each(['x', 'y', 'rotation', 'font-size', 'text'], function(i, attr){
      chronology[attr] = [ text.attr(attr) ];
    });

    if(now != 0){
      chronology.hidden = [ true ];
      chronology.hidden[now] = false;
    }

  });
});

//line tool
var line_count = 0;
$('#line_button').click(function(){//to get rid of jumpiness, change ".bind('keydown keypress', defer" to ".change("
  //startpoint for lines (including curves - don't move into lines)
  var startX = $('<p><label for="startX_field">start <i>x</i> : </label><input type="text" id="startX_field" name="startX_field"></p>'),
    startX_input = startX.find('input').bind('keydown keypress', defer(function(){
      var path = current_list_shape.data('path');
      path.startX = startX_input.val() || 0;
      current_list_shape.data('chronology').path[now] = current_list_shape.data('raphael').attr('path', path).attr('path');
    })),
    startY = $('<p><label for="startY_field">start <i>y</i></label> : <input type="text" id="startY_field" name="startY_field"></p>'),
    startY_input = startY.find('input').bind('keydown keypress', defer(function(){
      var path = current_list_shape.data('path');
      path.startY = startY_input.val() || 0;
      current_list_shape.data('chronology').path[now] = current_list_shape.data('raphael').attr('path', path).attr('path');
    })),
  //endpoint for lines (including curves - don't move into lines)
    endX = $('<p><label for="endX_field">end <i>x</i></label> : <input type="text" id="endX_field" name="endX_field"></p>'),
    endX_input = endX.find('input').bind('keydown keypress', defer(function(){
      var path = current_list_shape.data('path');
      path.endX = endX_input.val() || 0;
      current_list_shape.data('chronology').path[now] = current_list_shape.data('raphael').attr('path', path).attr('path');
    })),
    endY = $('<p><label for="endY_field">end <i>y</i></label> : <input type="text" id="endY_field" name="endY_field"></p>'),
    endY_input = endY.find('input').bind('keydown keypress', defer(function(){
      var path = current_list_shape.data('path');
      path.endY = endY_input.val() || 0;
      current_list_shape.data('chronology').path[now] = current_list_shape.data('raphael').attr('path', path).attr('path');
    }));
  function add_linepoints(raphael_shape, path){
    startX_input.val(path.startX);
    startY_input.val(path.startY);
    endX_input.val(path.endX);
    endY_input.val(path.endY);
    startX.insertBefore(remove);
    startY.insertBefore(remove);
    endX.insertBefore(remove);
    endY.insertBefore(remove);
  }
  function rm_linepoints(){
    startX.detach();
    startY.detach();
    endX.detach();
    endY.detach();
  }

  function moved_linepoints(){
    var path_attr = this.attr('path');
    $('#startX_field').val(path_attr[0][1]);
    $('#startY_field').val(path_attr[0][2]);
    $('#endX_field').val(path_attr[1][1]);
    $('#endY_field').val(path_attr[1][2]);
  }
  function doneMoving_linepoints(){
    var path = current_list_shape.data('path'), path_attr = this.attr('path');
    path.startX = path_attr[0][1];
    path.startY = path_attr[0][2];
    path.endX = path_attr[1][1];
    path.endY = path_attr[1][2];
    current_list_shape.data('chronology').path[now] = this.attr('path');
  }

  function Path(startX, startY, endX, endY){
    this.startX = this.endX = startX;
    this.startY = this.endY = startY;
  }
  Path.prototype.toString = function(){
    return 'M'+this.startX+' '+this.startY+'L'+this.endX +' '+this.endY;
  };

  return function(){
    user_canvas_div.mousedown(function(e){
      line_count += 1;
      var path = new Path(e.pageX - user_canvas_div.offset().left, e.pageY - user_canvas_div.offset().top), chronology = {}, attrs,
        line = user_canvas.path(path).mousedown(call_raphael_shape_mousedown),
        list_jQ = $('<p>Line '+line_count+'</p>').data('raphael', line)
          .data('chronology', chronology)
          .data('path', path)
          .data('add list options', function(){
            add_linepoints(line, path);
            attrs = (add_attr_option(line, 'rotation', chronology));
            add_stroke_width(line);
            add_stroke_color(line);
          })
          .data('remove list options', function(){
            attrs.remove();
            attrs = $();
            rm_linepoints();
            rm_stroke_width();
            rm_stroke_color();
          })
          .click(list_shape_click)
          .hover(function(){
            spotlight(line);
          }, function(){
            spotlight.off();
          })
          .appendTo(shapes_list);
      line.attr_options = function(){return attrs;};
      line.moved = moved_linepoints;
      line.doneMoving = doneMoving_linepoints;
      $(line.node).data('shapes list', list_jQ);

      spotlight(line);

      drag(e, function(dx, dy){
          path.endX = path.startX + dx;
          path.endY = path.startY + dy;
          line.attr({ path: path });
      }, function(){
        if(path.startX === path.endX && path.startY === path.endY){
          line.remove();
          list_jQ.remove();
          line_count -= 1;
          return;
        }
        list_shape_click.call(list_jQ[0]);

        $.each(['path', 'rotation'], function(i, attr){
          chronology[attr] = [ line.attr(attr) ];
        });
      });

      if(now != 0){
        chronology.hidden = [ true ];
        chronology.hidden[now] = false;
      }

      return false;
    });
  };
}());


//move tool
var x_attr, y_attr;
$('#move_button').click((function(){
  function move_click(){
    raphael_shape_mousedown = raphael_shape_mousedown_when_moving;
    user_canvas_div.mousedown(drag_when_moving);
  }
  function raphael_shape_mousedown_when_moving(e){
    if(current_list_shape.length)
      return;
    $(this.node).data('shapes list').click();
    same_raphael_shape = true;
  }
  var same_raphael_shape;
  function drag_when_moving(e){
    if(!current_list_shape.length)
      return;
    var current_raphael_shape = current_list_shape.data('raphael'),
      prev_dx = 0, prev_dy = 0, click = same_raphael_shape ? $.noop : canvas_click;
    same_raphael_shape = false;
    spotlight(current_raphael_shape);
    setTimeout(function(){
      click = $.noop;
    }, 500);
    drag(e, function(dx, dy){
      current_raphael_shape.translate(dx - prev_dx, dy - prev_dy).moved();
      prev_dx = dx;
      prev_dy = dy;
      click = $.noop;
    }, function(){
      current_raphael_shape.doneMoving();
      click();
    });
    return false;
  }
  function canvas_click(){
    $(document).click();
  }
  return move_click;
}()));


//embed button
$('button#embed').click(function(){
  $.get('raphael.js', function(raphael_js){
    $('<textarea></textarea>').val(
      '<div id="user_canvas"></div>\n' +
      '<div id="user_canvas_controls"><button>&#9654;Play</button><span id="timeslider"></span></div>\n' +
      '<div id="shapes_list" style="display:none">\n' +
      shapes_list.html() +
      '</div>\n' +
      '<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></scr'+'ipt>\n' +
      '<script type="text/javascript">\n' +
      raphael_js+'\n' +
      '<\/script>\n' +
      '<script type="text/javascript">\n' +
      $('script:eq(3)').html().replace(/^.*zoom.*$/mg, '//$&') +
      (function(){
        var str = '';
        shapes_list.children().each(function(i){
          var raphael_this = $(this).data('raphael'), chronology = $(this).data('chronology');
          if(!raphael_this)
            return;
          str += 'var shape = user_canvas.' + raphael_this.type + '(';
          for(var attr in chronology)
            str += chronology[attr][0];
          str += '), chronology = '+JSON.stringify(chronology)+';\n';
          str += 'for(var attr in chronology)\n';
          str += '  for(var i in chronology[attr])\n';
          str += '    if(chronology[attr][i] === null)\n';
          str += '      delete chronology[attr][i];\n';
          str += 'shapes_list.children(":eq('+i+')").data("raphael", shape)';
          str += '.data("chronology", chronology);\n';
        });
        return str;
      }()) +
      '<\/script>'
    ).appendTo('body');
  });
});


</script>

</body>
</html>
